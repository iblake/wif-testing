name: Test OCI WIF

on:
  workflow_dispatch:
  push:
    branches: ["main"]

permissions:
  id-token: write # Required for OIDC
  contents: read

jobs:
  test-auth:
    runs-on: ubuntu-latest
    name: Test OCI Authentication
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to OCI (Identity Domains WIF)
        env:
          IDCS_ENDPOINT: ${{ secrets.IDCS_ENDPOINT }}
          WIF_APP_CLIENT_ID: ${{ secrets.WIF_APP_CLIENT_ID }}
          WIF_APP_CLIENT_SECRET: ${{ secrets.WIF_APP_CLIENT_SECRET }}
          OCI_TENANCY_OCID: ${{ secrets.OCI_TENANCY_OCID }}
          OCI_REGION: ${{ secrets.OCI_REGION }}
        run: |
          # 1. Get GitHub OIDC Token
          echo "Fetching GitHub OIDC Token..."
          # Ask GitHub for an OIDC token with audience matching the issuer expected by IDCS
          GITHUB_TOKEN=$(curl -sLS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://token.actions.githubusercontent.com" \
            -H "Authorization: bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | jq -r '.value')

          if [ -z "$GITHUB_TOKEN" ] || [ "$GITHUB_TOKEN" == "null" ]; then
            echo "Failed to get GitHub OIDC Token"
            exit 1
          fi

          # 2. Exchange GitHub Token for OCI Token
          echo "Exchanging GitHub Token for OCI Token..."
          OCI_TOKEN_RESPONSE=$(curl -s -X POST "${IDCS_ENDPOINT}/oauth2/v1/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            --data-urlencode "grant_type=client_credentials" \
            --data-urlencode "client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer" \
            --data-urlencode "client_assertion=${GITHUB_TOKEN}" \
            --data-urlencode "client_id=${WIF_APP_CLIENT_ID}" \
            --data-urlencode "scope=urn:opc:idm:__myscopes__")
            
          ACCESS_TOKEN=$(echo "$OCI_TOKEN_RESPONSE" | jq -r '.access_token')

          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" == "null" ]; then
            echo "Failed to get OCI Access Token"
            echo "Response: $OCI_TOKEN_RESPONSE"
            exit 1
          fi
          echo "Successfully retrieved OCI Access Token"

          # 3. Configure OCI CLI
          mkdir -p ~/.oci

          # Generate a dummy key to satisfy CLI file existence checks (even if not used for signing)
          openssl genrsa -out ~/.oci/oci_api_key.pem 2048
          chmod 600 ~/.oci/oci_api_key.pem

          # Save the token
          echo "$ACCESS_TOKEN" > ~/.oci/oci_security_token
          chmod 600 ~/.oci/oci_security_token

          # Create config file
          cat <<EOF > ~/.oci/config
          [DEFAULT]
          security_token_file=/home/runner/.oci/oci_security_token
          key_file=/home/runner/.oci/oci_api_key.pem
          tenancy=${OCI_TENANCY_OCID}
          region=${OCI_REGION}
          authentication_type=security_token_file
          EOF

      - name: Verify Access (IDCS UserInfo)
        run: |
          # Verify the token works against IDCS
          curl -s -H "Authorization: Bearer $(cat ~/.oci/oci_security_token)" \
            "${{ secrets.IDCS_ENDPOINT }}/oauth2/v1/userinfo" | jq .

      - name: Verify Access (OCI CLI)
        env:
          OCI_CLI_AUTH: security_token
          OCI_CLI_PROFILE: DEFAULT
        run: |
          # Try to list namespace (might require signature, but let's test)
          oci os ns get || echo "OCI CLI failed, but IDCS Auth worked."
